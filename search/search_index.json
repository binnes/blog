{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":""},{"location":"2025/11/04/introduction-to-devcontainers/","title":"Introduction to Devcontainers","text":"<p>Devcontainers (short for development containers) are a way of describing, building, and running a complete development environment inside a container.</p> <p>The definition lives in a small JSON/YAML file (devcontainer.json) together with optional Container assets that live under a .devcontainer/ folder at the root of your project.</p>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#tldr","title":"TL;DR","text":"<ul> <li>Devcontainers = declarative Container\u2011based dev environments that work locally (VS\u202fCode Remote \u2013 Containers) and in the cloud (Codespaces, Gitpod).</li> <li>Choose a source: pre\u2011built image, custom Containerfile, or docker\u2011compose stack.</li> <li>Enrich your environment with features, which are reusable install scripts; be mindful of OS\u2011specific quirks.</li> <li>Hook into the lifecycle via configurable commands which run at defined points in the creation and setup process. Install VS\u202fCode extensions declaratively or via script.</li> <li>Adopt them in a project by adding a .devcontainer/ folder, opening the repo in VS\u202fCode, and letting the tooling do the rest.</li> <li>Speed matters: use the Dev Container CLI for CI, and consider pre\u2011building and publishing a custom image to avoid repeated builds.</li> </ul>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#why-use-them","title":"Why use them?","text":"<ul> <li>Consistency: Every teammate (or CI job - automated build job for a Continuous Integration pipeline) gets exactly the same tools, libraries, and OS\u2011level dependencies. No more \u201cit works on my machine\u201d.</li> <li>Isolation: Your host stays clean\u2014no global npm/pip/ruby installations that could clash with other projects.</li> <li>Portability: The same definition can be used locally (VS\u202fCode Remote \u2013 Containers), in the cloud (GitHub Codespaces, Gitpod) or on any CI platform that supports Containers.</li> <li>Speed of onboarding: New contributors just open the repo and click \u201cReopen in Container\u201d. All tooling is ready within seconds. In short, devcontainers let you treat the entire development stack as code.</li> </ul>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#how-to-use-devcontainers","title":"How to use Devcontainers?","text":"<p>Devcontainers is a technology that allows a custom environment to be created based on container technology.</p> <p>When VS\u202fCode (or another IDE or client) sees a .devcontainer/ folder it reads devcontainer.json, builds or pulls the referenced Container image(s), runs any defined scripts, and finally mounts your source code into the resulting container. The workflow looks like this:</p> <pre><code>---\ntitle: Devcontainers\nconfig:\n  layout: elk\n---\n\nflowchart TD\n%% ---------- Sources ----------\nsubgraph Sources\n    img[\"Container Image\"] --&gt;|pull| createDevcontainer[Create Devcontainer]\n    df[\"Containerfile\"]   --&gt;|podman build| createDevcontainer\n    dc[\"docker\u2011compose.yml\"] --&gt;|docker compose up| createDevcontainer\nend\n\n%% ---------- Creation ----------\ncreateDevcontainer --&gt; decideFeatures{Add Features?}  \n\n%% ---------- Feature selection ----------\ndecideFeatures -- Yes --&gt; feat1[\"Feature 1 (e.g., Node, Python)\"]\ndecideFeatures -- Yes --&gt; feat2[\"Feature 2 (VS\u202fCode extension)\"]\ndecideFeatures -- Yes --&gt; featN[\"Feature N \u2026\"]\ndecideFeatures -- No --&gt; decideScripts{Add Commands / Scripts?}\n\n%% Aggregate feature install scripts\nsubgraph Feature_Stage\n    direction TB\n    feat1 --&gt; installScripts[Run Feature Install Scripts]\n    feat2 --&gt; installScripts\n    featN --&gt; installScripts\nend\n\n%% ---------- Commands / Scripts ----------\ninstallScripts --&gt; decideScripts{\"Add Commands / Scripts / Customisations?\"}\n\ndecideScripts -- Yes --&gt; preCreate[\"Pre\u2011create script (init.sh)\"]\ndecideScripts -- Yes --&gt; postCreate[\"Post\u2011create script (setup.sh)\"]\ndecideScripts -- Yes --&gt; onStart[\"On\u2011start command (e.g., npm start)\"]\ndecideScripts -- Yes --&gt; customizations[\"Customizations to vscode\"]\ndecideScripts -- No --&gt; ready[Container Ready]\n\n%% ---------- Final container ----------\nsubgraph Final_Devcontainer\n    direction TB\n    preCreate --&gt; ready\n    postCreate --&gt; ready\n    onStart   --&gt; ready\n    customizations --&gt; ready\nend</code></pre>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#source","title":"Source","text":"<p>A devcontainer can be created from three primary sources. Each source determines how the base image (the \u201cstarting point\u201d of your container) is obtained:</p> Source How it works Typical use\u2011case Container Image (\"image\": \"node:20\" in devcontainer.json) VS\u202fCode pulls a pre\u2011built image from a registry (Docker Hub, Quay.io, GHCR, etc.) and uses it as the base. No build step is required. Quick prototypes where you only need a known runtime (e.g., python:3.13). Containerfile (\"dockerFile\": \"Containerfile\" ) The CLI builds an image locally using the Containerfile you provide, then runs that image. This gives full control over OS packages and custom layers. When you need extra system libraries, custom user creation, or a non\u2011standard base (e.g., Alpine + OpenJDK). docker\u2011compose.yml (\"dockerComposeFile\": \"docker-compose.yml\" ) A compose file can define multiple services (database, cache, etc.). One of the services is marked as the \u201cworkspace\u201d container and gets the devcontainer features. The other containers are started in parallel and remain reachable via their service names. Full\u2011stack apps where you want a DB, Redis, or a message broker running alongside your IDE. Only the workspace container is mounted into VS\u202fCode; all others act as supporting services. <p>Note</p> <p>In a compose scenario only one service can be designated as the development container (the one that receives the devcontainer.json configuration). The rest are treated as background services.</p>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#features","title":"Features","text":"<p>Features are reusable, community\u2011maintained scripts that extend a devcontainer without you having to write low\u2011level install steps. They live in the Dev Container Feature Registry, can be pulled directly from the web or loaded locally and can be referenced directly in devcontainer.json:</p> <pre><code>{\n  \"features\": {\n    \"ghcr.io/devcontainers/features/node:1\": { \"version\": \"20\" },\n    \"ghcr.io/devcontainers/features/python:2\": { \"version\": \"3.12\", \"installTools\": true }\n  }\n}\n</code></pre> <p>Features can provide support for programming languages such as JavaScript, Java or Python, a capability such as running containers within a container or tool such as Skopeo which allows images to be copied between registries.</p> <p>When the container is built, each feature runs its own install script (usually a Bash snippet) that adds the requested toolset and optionally sets up environment variables.</p>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#issues-with-different-os-distributions","title":"Issues with different OS distributions","text":"<p>Features are written against a base distribution\u2014most of them target Debian/Ubuntu because those images dominate the devcontainer ecosystem. This can cause friction when you:</p> <ul> <li>Choose Alpine: Alpine uses apk instead of apt. A feature that runs apt-get install will fail unless it detects the distro and switches to apk. Some features include such detection, but many do not.</li> <li>Pick Red\u202fHat\u2011based images (Fedora, RHEL, UBI): The package manager changes to dnf/yum. Again, you need either a feature that explicitly supports those or you must write your own.</li> <li>Use non\u2011Linux OS: Features assume Linux; they cannot run on Windows containers.</li> </ul> <p>If you need a non\u2011Debian base, the safest path is to fork an existing feature and adapt its install script, or write a custom feature from scratch (the registry supports that out of the box).</p>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#scripts-and-customisations","title":"Scripts and Customisations","text":"<p>Beyond features, devcontainers let you hook into the lifecycle at several points. This is where you can run arbitrary commands, copy files, or tweak VS\u202fCode itself.</p> Lifecycle hook Where to define it When it runs initializeCommand In devcontainer.json (\"initializeCommand\": \"./.devcontainer/init.sh\" ) Executed before the Docker image is built. Useful for generating files that affect the build (e.g., writing a .npmrc). Feature install Declared under \"features\"; run automatically during image build after the base Containerfile steps. During container build \u2013 before the container starts. onCreateCommand In devcontainer.json (\"onCreateCommand\": \"./devcontainer/setup.sh\" ) This command is run inside a container immediately after it has started for the first time. updateContentCommand In devcontainer.json (\"updateContentCommand\": \"./devcontainer/update.sh\" ) This command runs after onCreateCommand It executes inside the container whenever new content is available in the source tree during the creation process, but will execute at least once. postCreateCommand (setup.sh) In devcontainer.json (\"postCreateCommand\": \"./.devcontainer/setup.sh\" ) Runs inside the running container after it has started and been assigned to a user for the first time, but before VS\u202fCode attaches. Ideal for installing npm packages, creating virtual environments, or seeding a database. postStartCommand In devcontainer.json (\"postStartCommand\": \"npm start\") Executed each time the container is re\u2011started (e.g., after you stop and reopen). Good for launching long\u2011running processes like a local server or watch task. postAttachCommand In devcontainer.json (\"postAttachCommand\": \"./.devcontainer/attach.sh\" ) Runs each time a tool has successfully attached to the container VS\u202fCode extensions \"extensions\": [\"ms-python.python\", \"dbaeumer.vscode-eslint\"] in devcontainer.json VS\u202fCode installs the listed extensions automatically when it connects to the container. <p>Example: Adding a custom script</p> <pre><code># .devcontainer/setup.sh\n#!/usr/bin/env bash\nset -e\n\necho \"Installing project\u2011level npm dependencies...\"\nnpm ci\n\necho \"Creating Python virtual environment...\"\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\n\n# Optional: run a one\u2011time DB migration\nif [ -f manage.py ]; then\n  python manage.py migrate --noinput\nfi\n</code></pre> <p>And the matching devcontainer.json snippet:</p> <pre><code>{\n  \"name\": \"My Awesome App\",\n  \"dockerFile\": \"Containerfile\",\n  \"features\": {\n    \"ghcr.io/devcontainers/features/node:1\": { \"version\": \"20\" },\n    \"ghcr.io/devcontainers/features/python:2\": { \"installTools\": true }\n  },\n  \"postCreateCommand\": \"./.devcontainer/setup.sh\",\n  \"extensions\": [\n    \"ms-python.python\",\n    \"dbaeumer.vscode-eslint\"\n  ],\n  \"forwardPorts\": [3000, 5432],\n  \"remoteUser\": \"vscode\"\n}\n</code></pre>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#adding-vs-code-extensions-via-scripts-alternative","title":"Adding VS\u202fCode extensions via scripts (alternative)","text":"<p>You can install VS Code Extensions from the marketplace or a Git Repo .  However, if you need to install an extension that isn\u2019t available on the marketplace or want a specific version, you can do it in postCreateCommand:</p> <pre><code>code --install-extension ms-toolsai.jupyter@2024.9.0 --force\n</code></pre> <p>The CLI code is pre\u2011installed inside the container runtime.</p>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#using-devcontainers","title":"Using Devcontainers","text":"<p>Putting everything together, here\u2019s a step\u2011by\u2011step guide to adopt devcontainers in an existing project:</p> <ol> <li> <p>Create the .devcontainer/ folder at the root of your repo.</p> </li> <li> <p>Add a Containerfile (or pick an image) that contains the OS you want. A minimal example for Node + Python:</p> <pre><code># .devcontainer/Containerfile\nFROM mcr.microsoft.com/vscode/devcontainers/base:ubuntu-22.0\n\n# Install any global system packages you need\nRUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \\\n    &amp;&amp; apt-get install -y --no-install-recommends git curl\n</code></pre> </li> <li> <p>Write devcontainer.json referencing the Containerfile and desired features/extensions (see previous section for a full example).</p> </li> <li> <p>Open the folder in VS\u202fCode. You\u2019ll see a prompt:</p> <p>VSCode prompt</p> <p>\u201cFolder contains a Dev Container configuration \u2013 Reopen in Container?\u201d</p> <p>Click it, or run the command Remote-Containers: Open Folder in Container.</p> </li> <li> <p>VS\u202fCode will now:</p> <ul> <li>Build the image (caching layers where possible).</li> <li>Run any preCreateCommand / feature install scripts.</li> <li>Start the container and execute postCreateCommand.</li> <li>Attach the editor, installing listed extensions automatically.</li> </ul> </li> <li> <p>Start coding! Your terminal (`Ctrl+``) is already inside the container, your project files are mounted at /workspace/ within the container, your ports are forwarded, and you can run debuggers as if they were local.","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#using-devcontainers-on-github-codespaces","title":"Using Devcontainers on GitHub Codespaces","text":"<p>The same devcontainer.json works unchanged in GitHub Codespaces:</p> <ol> <li>Push your repo to GitHub.</li> <li>Click Code \u2192 Codespaces \u2192 New codespace (or add a .devcontainer/devcontainer.json reference in the repository\u2019s Codespaces settings).</li> <li>The platform builds the container on the backend and presents you with an online VS\u202fCode instance. No extra configuration is required\u2014this is one of the biggest advantages of keeping everything declarative.</li> </ol>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#speeding-up-containers","title":"Speeding up Containers","text":"<p>While devcontainers are great for reproducibility, building them from scratch each time can feel slow, especially in CI pipelines or when onboarding many developers. Two strategies help you keep the experience snappy:</p>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#the-devcontainer-cli-command-line-interface","title":"The devcontainer CLI - Command Line Interface","text":"<p>Microsoft ships a Dev Container CLI (devcontainer) that mirrors the VS\u202fCode UI workflow but runs entirely in your terminal. Typical commands:</p> <pre><code># Build the container without launching VS Code (useful for CI)\ndevcontainer build --workspace-folder . --output-path ./image.tar\n\n# Start a devcontainer and attach a shell\ndevcontainer up --workspace-folder .\ndevcontainer exec --workspace-folder . -- bash\n</code></pre> <p>The CLI respects all devcontainer.json options, runs feature install scripts, and caches layers in Docker\u2019s normal cache. Using it in CI lets you run tests inside the same environment developers use locally.</p>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#prebuild-a-custom-image-and-push-to-a-registry","title":"Pre\u2011build a custom image and push to a registry","text":"<p>If your devcontainer has heavy system dependencies (e.g., large language runtimes, compiled libraries), consider pre\u2011building an image once and reusing it:</p> <ol> <li> <p>Create a dedicated Containerfile that includes all features you always need.</p> <pre><code># .devcontainer/Containerfile.prebuilt\nFROM mcr.microsoft.com/vscode/devcontainers/base:ubuntu-22.04\n\n# Install Node, Python, and common tools in one layer\nRUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \\\n    &amp;&amp; apt-get install -y curl git build-essential \\\n    &amp;&amp; curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \\\n    &amp;&amp; apt-get install -y nodejs python3-pip\n\n# Optional: install VS Code extensions globally (they\u2019ll be available for any container based on this image)\nRUN code --install-extension ms-python.python \\\n    &amp;&amp; code --install-extension dbaeumer.vscode-eslint\n</code></pre> </li> <li> <p>Build and push the image:</p> <pre><code>podman build -t quay.io/your-org/my-devcontainer:latest -f .devcontainer/Containerfile.prebuilt .\npodman push quay.io/your-org/my-devcontainer:latest\n</code></pre> <p>Note</p> <p>If your devcontainer definition contains features, you can use the devcontainer CLI to build the image from the devcontainer.json definition.  Using <code>devcontainer build</code> rather than <code>podman build</code> will include all the features within the build image.  This can further reduce the work needed to be done when the devcontainer starts.</p> <p>Running <code>devcontainer build --help</code> shows all the possible command line options available,</p> </li> <li> <p>Reference the pre\u2011built image in devcontainer.json:</p> <pre><code>{\n  \"name\": \"Pre\u2011built Dev Container\",\n  \"image\": \"quay.io/your-org/my-devcontainer:latest\",\n  \"features\": {},\n  \"extensions\": [],\n  \"postCreateCommand\": \"./.devcontainer/setup.sh\"\n}\n</code></pre> <p>Now, when a developer opens the repo, VS\u202fCode only needs to pull the image (seconds) instead of rebuilding it layer\u2011by\u2011layer. The same image can be used in CI:</p> <pre><code># .github/workflows/ci.yml\njobs:\n  test:\n    runs-on: ubuntu-latest\n    container:\n      image: quay.io/your-org/my-devcontainer:latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Run tests\n        run: npm test   # or pytest, etc.\n</code></pre> </li> </ol>","tags":["personal"]},{"location":"2025/11/04/introduction-to-devcontainers/#bonus-tip-multistage-containerfiles-for-faster-builds","title":"Bonus tip: Multi\u2011stage Containerfiles for faster builds","text":"<p>If you need to compile something (e.g., native Node addons), split the build into two stages:</p> <pre><code># Build stage \u2013 heavy tools, compilers\nFROM mcr.microsoft.com/vscode/devcontainers/base:ubuntu-22.04 AS builder\nRUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \\\n    &amp;&amp; apt-get install -y build-essential cmake\n\n# Compile your native module here...\nCOPY src/ /src/\nRUN cd /src &amp;&amp; make\n\n# Runtime stage \u2013 slim, only runtime deps\nFROM mcr.microsoft.com/vscode/devcontainers/base:ubuntu-22.04\nCOPY --from=builder /src/build/output.so /usr/local/lib/\n</code></pre> <p>Only the lightweight runtime image ends up in the registry, dramatically reducing pull size.</p> <p>Give it a try on your next project\u2014your future self (and every teammate) will!</p>","tags":["personal"]},{"location":"2025/10/28/welcome/","title":"Welcome","text":"<p>Hello and welcome to my personal blog.</p>","tags":["personal"]},{"location":"2025/10/28/welcome/#tldr","title":"TL;DR","text":"<ul> <li>An introduction to the blog and its purpose</li> <li>A quick snapshot of the topics covered:<ul> <li>Developer\u2011focused insights</li> <li>Reflections on technology trends</li> <li>Personal experiences and observations</li> </ul> </li> </ul>","tags":["personal"]},{"location":"2025/10/28/welcome/#what-is-this-blog-about","title":"What is this blog about?","text":"<p>This blog is primarily developer\u2011focused, covering the technologies I encounter in my work and the tools that improve the developer workflow. While many posts will discuss IBM technology, I will also explore a broader range of solutions and ideas. The content reflects my personal thoughts and experiences and does not represent IBM.</p>","tags":["personal"]},{"location":"2025/10/28/welcome/#who-am-i","title":"Who am I?","text":"<p>I was born in North\u2011East England and am a Geordie by birth. I spent a couple of years in Glasgow, Scotland, but the majority of my adult life has been on England\u2019s south coast due to work.</p> <p>I began working in retail finance at the age of sixteen, but quickly realised it was not a long\u2011term career for me. </p> <p>I earned a first\u2011class BSc (Hons) from Newcastle University and have worked in the IT industry ever since.</p> <p>My career has included roles at:</p> <ul> <li>Logica Finance (the parent company Logica was acquired by CGI Inc in 2012)</li> <li>Abbey Life</li> <li>IBM</li> </ul> <p>I am approaching thirty years at IBM, having held many varied positions that have given me a broad view of enterprise computing.</p> <p>My career at IBM spans nearly three decades, during which I have worked on a wide range of enterprise\u2011computing areas:</p> <ul> <li>I contributed to adding commerce to games before online gaming existed</li> <li>created mobile enterprise applications before smartphones were commonplace</li> <li>supporting partners in adopting IBM technology, including: <ul> <li>enterprise Java development with IBM WebSphere products</li> <li>work on the portal era</li> <li>enterprise messaging</li> <li>mobile applications</li> <li>sensors and actuators (including RFID track\u2011and\u2011trace and MQTT telemetry)</li> <li>artificial intelligence.</li> </ul> </li> </ul>","tags":["personal"]},{"location":"archive/2025/","title":"November 2025","text":""},{"location":"category/devcontainers/","title":"devcontainers","text":""},{"location":"category/application-development/","title":"application development","text":""},{"location":"category/containers/","title":"containers","text":""},{"location":"category/general/","title":"general","text":""}]}